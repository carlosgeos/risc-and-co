movi 1, 0x7fff // First operand
movi 2, 0x0007 // Second operand
movi 3, 0x0000 // Result register (LSB)
movi 4, 0x0000 // Result register (MSB)

movi 5, 0x0001 // Mask the least significant bit

movi 6, 0x0000 // TMP register
movi 7, 0x0000 // Second operand MSB (when shifting)

// As we go through the loop we shift right the first operand to retrieve its
// LSB easily and shift left the second operand to add it each time the LSB equal
// To one

loop: beq 1, 0, end
      nand 6, 5, 1                    // Verify the LSB of the first operand
      nand 6, 6, 6
      beq 6, 5, acc
      beq 0, 0, shifts
acc:  add 4, 4, 7 										// Add the MSB of the second operand ()
      add 3, 3, 2, result_msb_inc     // Add the shifted second operand and store the carry in the register 4 (MSB of the result)
      beq 0, 0, shifts
result_msb_inc: addi 4, 4, 1
shifts: shifti 1, 1, -1               // Shift first operand to the right for easy LSB check
        shifti 7, 7, 1                // Also shift the content of the MSB of the second operand
        sha 2, 2, 5, operand_msb_inc  // Shift the second operand we add in the result with matching
                                      // 	bit of the first operand we are multiplying.
                                      // If carry we add the this to a register to save for later
        beq 0, 0, loop
operand_msb_inc: addi 7, 7, 1 				// Add the carry shifted (for later)
                 beq 0, 0, loop

end: halt
